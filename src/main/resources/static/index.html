<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Audio Only WebRTC PoC</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 20px auto; }
    #callId { width: 200px; padding: 5px; }
    button { padding: 10px; margin: 5px; cursor: pointer; }
    .status { margin: 10px 0; padding: 10px; background: #f0f0f0; }
  </style>
</head>
<body>
<h1>Audio Only WebRTC Call</h1>

<div>
  <label for="callId">Call ID:</label>
  <input type="text" id="callId" value="test-call">
</div>

<div>
  <button onclick="startCall()">Start Call (Caller)</button>
  <button onclick="answerCall()">Answer Call (Callee)</button>
  <button onclick="hangUp()">Hang Up</button>
</div>

<div id="status" class="status">Status: Ready</div>

<div>
  <h3>Local Audio</h3>
  <audio id="localAudio" controls muted></audio>
</div>

<div>
  <h3>Remote Audio</h3>
  <audio id="remoteAudio" controls></audio>
</div>

<script>
  const serverUrl = 'http://localhost:8080';
  const STUN_SERVER = { 
        urls: [
            'stun:stun.l.google.com:19302'
        ]
    };

  const localAudio = document.getElementById('localAudio');
  const remoteAudio = document.getElementById('remoteAudio');
  const callIdInput = document.getElementById('callId');
  const statusDiv = document.getElementById('status');

  let localStream;
  let peerConnection;
  let iceInterval;
  let pollInterval;
  let currentCallId;

  function updateStatus(message) {
      statusDiv.textContent = 'Status: ' + message;
      console.log(message);
  }

  // 1. Получить доступ только к микрофону
  async function startAudioStream() {
      try {
          localStream = await navigator.mediaDevices.getUserMedia({
              audio: true,
              video: false
          });
          localAudio.srcObject = localStream;
          updateStatus('Microphone access granted');
          return true;
      } catch (err) {
          console.error('Error accessing microphone.', err);
          updateStatus('Error: ' + err.message);
          return false;
      }
  }

  // 2. Создать и настроить PeerConnection (ТОЛЬКО АУДИО)
  function createPeerConnection() {
      peerConnection = new RTCPeerConnection({iceServers: [STUN_SERVER]});

      // Добавляем только аудио-трек
      const audioTracks = localStream.getAudioTracks();
      if (audioTracks.length > 0) {
          peerConnection.addTrack(audioTracks[0], localStream);
      }

      // Обрабатываем входящий аудио-поток
      peerConnection.ontrack = (event) => {
          console.log("Received remote audio stream!");
          remoteAudio.srcObject = event.streams[0];
          updateStatus('Connected!');
      };

      // Собираем ICE-кандидаты и сразу отправляем
      peerConnection.onicecandidate = (event) => {
          // Этот колбек вызывается КАЖДЫЙ РАЗ когда находится новый кандидат
          if (event.candidate) {
              // Отправляем КАЖДОГО кандидата сразу на сервер
              fetch(`${serverUrl}/api/signal/ice-candidate/${currentCallId}`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(event.candidate.toJSON())
              }).catch(error => {
                  console.error('Error sending ICE candidate:', error);
              });
          }
      };

      peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          updateStatus('Connection state: ' + state);
          
          if (state === 'connected') {
              // Останавливаем поллинг при успешном соединении
              if (pollInterval) clearInterval(pollInterval);
          } else if (state === 'disconnected' || state === 'failed') {
              hangUp();
          }
      };
  }

  // 3. Функция для получения ICE-кандидатов
  async function pollIceCandidates(callId) {
      return setInterval(async () => {
          try {
              const response = await fetch(`${serverUrl}/api/signal/ice-candidates/${callId}`);
              if (response.ok) {
                  const candidates = await response.json();
                  
                  for (const candidateData of candidates) {
                      try {
                          await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData));
                          console.log('Added ICE candidate');
                      } catch (error) {
                          console.warn('Error adding ICE candidate:', error);
                      }
                  }
              }
          } catch (error) {
              console.error('Error fetching ICE candidates:', error);
          }
      }, 1000);
  }

  // 4. Инициатор звонка (Caller)
  async function startCall() {
      updateStatus('Starting call...');
      currentCallId = callIdInput.value;

      if (!await startAudioStream()) return;
      
      createPeerConnection();

      // Создаем и отправляем offer
      try {
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);

          await fetch(`${serverUrl}/api/signal/offer/${currentCallId}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  type: offer.type,
                  sdp: offer.sdp
              })
          });

          updateStatus('Offer sent, waiting for answer...');

          // Запускаем поллинг для answer и ICE кандидатов
          pollInterval = setInterval(async () => {
              try {
                  // Проверяем answer
                  const answerResponse = await fetch(`${serverUrl}/api/signal/answer/${currentCallId}`);
                  if (answerResponse.ok) {
                      const answerData = await answerResponse.json();
                      
                      if (answerData.type && answerData.sdp) {
                          await peerConnection.setRemoteDescription(new RTCSessionDescription(answerData));
                          updateStatus('Answer received, connecting...');
                          clearInterval(pollInterval);
                          
                          // Запускаем поллинг ICE кандидатов
                          pollInterval = await pollIceCandidates(currentCallId);
                      }
                  }
              } catch (error) {
                  console.error('Error polling:', error);
              }
          }, 1000);

      } catch (error) {
          console.error('Error starting call:', error);
          updateStatus('Error starting call');
      }
  }

  // 5. Ответчик (Callee)
  async function answerCall() {
      updateStatus('Answering call...');
      currentCallId = callIdInput.value;

      if (!await startAudioStream()) return;

      // Сначала ждем offer
      const offerPollInterval = setInterval(async () => {
          try {
              const response = await fetch(`${serverUrl}/api/signal/offer/${currentCallId}`);
              if (response.ok) {
                  const offerData = await response.json();
                  
                  if (offerData.type && offerData.sdp) {
                      clearInterval(offerPollInterval);
                      
                      createPeerConnection();
                      
                      // Устанавливаем полученный offer
                      await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData));

                      // Создаем и отправляем answer
                      const answer = await peerConnection.createAnswer();
                      await peerConnection.setLocalDescription(answer);

                      await fetch(`${serverUrl}/api/signal/answer/${currentCallId}`, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                              type: answer.type,
                              sdp: answer.sdp
                          })
                      });

                      updateStatus('Call answered!');
                      
                      // Запускаем поллинг ICE кандидатов
                      pollInterval = await pollIceCandidates(currentCallId);
                  }
              }
          } catch (error) {
              console.error('Error checking for offer:', error);
          }
      }, 1000);
  }

  // 6. Завершение звонка
  function hangUp() {
      if (pollInterval) {
          clearInterval(pollInterval);
      }
      if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
      }
      if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
      }
      if (currentCallId) {
          // Очищаем на сервере
          fetch(`${serverUrl}/api/signal/cleanup/${currentCallId}`, { 
              method: 'DELETE' 
          }).catch(console.error);
      }
      
      localAudio.srcObject = null;
      remoteAudio.srcObject = null;
      updateStatus('Call ended');
      currentCallId = null;
  }
</script>
</body>
</html>