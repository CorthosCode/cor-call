<!DOCTYPE html>
<html>
<head>
  <title>Audio Only WebRTC PoC</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 20px auto; }
    #callId { width: 200px; padding: 5px; }
    button { padding: 10px; margin: 5px; cursor: pointer; }
    .status { margin: 10px 0; padding: 10px; background: #f0f0f0; }
  </style>
</head>
<body>
<h1>Audio Only WebRTC Call</h1>

<div>
  <label for="callId">Call ID:</label>
  <input type="text" id="callId" value="test-call-123">
</div>

<div>
  <button onclick="startCall()">Start Call (Caller)</button>
  <button onclick="answerCall()">Answer Call (Callee)</button>
  <button onclick="hangUp()">Hang Up</button>
</div>

<div id="status" class="status">Status: Ready</div>

<div>
  <h3>Local Audio</h3>
  <audio id="localAudio" controls muted></audio>
</div>

<div>
  <h3>Remote Audio</h3>
  <audio id="remoteAudio" controls></audio>
</div>

<script>
  const localAudio = document.getElementById('localAudio');
  const remoteAudio = document.getElementById('remoteAudio');
  const callIdInput = document.getElementById('callId');
  const statusDiv = document.getElementById('status');

  let localStream;
  let peerConnection;
  let isCaller = false;
  const serverUrl = 'http://localhost:8080';
  const iceCandidatesQueue = [];
  let iceInterval;

  function updateStatus(message) {
      statusDiv.textContent = 'Status: ' + message;
      console.log(message);
  }

  // 1. Получить доступ только к микрофону
  async function startAudioStream() {
      try {
          localStream = await navigator.mediaDevices.getUserMedia({
              audio: true,
              video: false // ВЫКЛЮЧАЕМ ВИДЕО
          });
          localAudio.srcObject = localStream;
          updateStatus('Microphone access granted');
      } catch (err) {
          console.error('Error accessing microphone.', err);
          updateStatus('Error: ' + err.message);
      }
  }

  // 2. Создать и настроить PeerConnection (ТОЛЬКО АУДИО)
  function createPeerConnection() {
      const config = {
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      };

      peerConnection = new RTCPeerConnection(config);

      // Добавляем только аудио-трек
      const audioTracks = localStream.getAudioTracks();
      if (audioTracks.length > 0) {
          peerConnection.addTrack(audioTracks[0], localStream);
      }

      // Обрабатываем входящий аудио-поток
      peerConnection.ontrack = (event) => {
          console.log("Received remote audio stream!");
          remoteAudio.srcObject = event.streams[0];
          updateStatus('Connected!');
      };

      // Собираем ICE-кандидаты
      peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
              iceCandidatesQueue.push(event.candidate.toJSON());
          }
      };

      peerConnection.onconnectionstatechange = () => {
          updateStatus('Connection state: ' + peerConnection.connectionState);
      };
  }

  // 3. Функция для отправки ICE-кандидатов
  async function sendIceCandidates(callId) {
      iceInterval = setInterval(async () => {
          if (iceCandidatesQueue.length > 0) {
              const candidate = iceCandidatesQueue.shift();
              try {
                  await fetch(`${serverUrl}/api/signal/ice-candidate/${callId}`, {
                      method: 'POST',
                      body: JSON.stringify(candidate),
                      headers: { 'Content-Type': 'application/json' }
                  });
              } catch (error) {
                  console.error('Error sending ICE candidate:', error);
              }
          }
      }, 500);
  }

  // 4. Функция для получения ICE-кандидатов
  async function receiveIceCandidates(callId) {
    const interval = setInterval(async () => {
        try {
            const response = await fetch(`${serverUrl}/api/signal/ice-candidates/${callId}`);
            const candidates = await response.json();

            for (const candidateData of candidates) {
                try {
                    // Преобразуем полученные данные в объект для addIceCandidate
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData));
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }
        } catch (error) {
            console.error('Error fetching ICE candidates:', error);
        }
    }, 1000);
    return interval; // Возвращаем interval ID для очистки
  }

  // 5. Инициатор звонка (Caller)
  async function startCall() {
      isCaller = true;
      updateStatus('Starting call...');

      await startAudioStream();
      createPeerConnection();
      const callId = callIdInput.value;

      // Создаем и отправляем offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      await fetch(`${serverUrl}/api/signal/offer/${callId}`, {
          method: 'POST',
          body: offer.sdp,
          headers: { 'Content-Type': 'text/plain' }
      });

      updateStatus('Offer sent, waiting for answer...');
      sendIceCandidates(callId);

      // Ждем answer
      const answerInterval = setInterval(async () => {
          try {
              const response = await fetch(`${serverUrl}/api/signal/answer/${callId}`);
              const answerSdp = await response.text();

              if (answerSdp) {
                  clearInterval(answerInterval);
                  await peerConnection.setRemoteDescription({
                      type: 'answer',
                      sdp: answerSdp
                  });
                  updateStatus('Answer received, connecting...');
                  receiveIceCandidates(callId);
              }
          } catch (error) {
              console.error('Error checking for answer:', error);
          }
      }, 1000);
  }

  // 6. Ответчик (Callee)
  async function answerCall() {
      isCaller = false;
      updateStatus('Answering call...');

      await startAudioStream();
      createPeerConnection();
      const callId = callIdInput.value;

      sendIceCandidates(callId);

      // Ждем offer
      const offerInterval = setInterval(async () => {
          try {
              const response = await fetch(`${serverUrl}/api/signal/offer/${callId}`);
              const offerSdp = await response.text();

              if (offerSdp) {
                  clearInterval(offerInterval);
                  await peerConnection.setRemoteDescription({
                      type: 'offer',
                      sdp: offerSdp
                  });

                  // Создаем и отправляем answer
                  const answer = await peerConnection.createAnswer();
                  await peerConnection.setLocalDescription(answer);

                  await fetch(`${serverUrl}/api/signal/answer/${callId}`, {
                      method: 'POST',
                      body: answer.sdp,
                      headers: { 'Content-Type': 'text/plain' }
                  });

                  updateStatus('Call answered!');
                  receiveIceCandidates(callId);
              }
          } catch (error) {
              console.error('Error checking for offer:', error);
          }
      }, 1000);
  }

  // 7. Завершение звонка
  function hangUp() {
      if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
      }
      if (iceInterval) {
          clearInterval(iceInterval);
      }
      if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
      }
      localAudio.srcObject = null;
      remoteAudio.srcObject = null;
      updateStatus('Call ended');
  }
</script>
</body>
</html>